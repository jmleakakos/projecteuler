# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?
def is_prime(n):
    if (n == 2):
        return True
    if (n % 2 == 0):
        return False
    limit = int(n ** (.5)) + 1
    for i in range(3,limit,2):
        if n % i == 0:
            return False
    return True

def primes_up_to(n):
    primes = [2]
    primes.extend(filter(lambda x: is_prime(x),range(3, n, 2)))
    return primes

maxPrime = 100000
primes = primes_up_to(maxPrime)

def pf_no_recursion(number, prime_index, counts):
    cont = True
    while(cont):
        prime = primes[prime_index]
        included = prime in counts
        count = 0 if not included else counts[prime]
        div, mod = divmod(number, prime)
        if mod == 0:
            counts[prime] = count + 1
            number = div
            if div == 1:
                cont = False
        else:
            prime_index += 1
    return counts

def pf(number, prime_index, counts):
    prime = primes[prime_index]
    included = prime in counts
    count = 0 if not included else counts[prime]
    div, mod = divmod(number, prime)

    if mod == 0:
        counts[prime] = count + 1
        number = div
        if div == 1:
            return counts
        # else:
        #     return pf(div, prime_index, counts)
    else:
        prime_index += 1
        # return pf(number, prime_index, counts)
    return pf(number, prime_index, counts)

def prime_factorization_of(n):
    # Apparently there is no default tail call optimizaion
    #return pf(n, 0, {})
    return pf_no_recursion(n, 0, {})

def number_of_divisors(n):
    if n == 1:
        return 0
    prime_factors = prime_factorization_of(n)
    return product([prime_factors[p]+1 for p in prime_factors.keys()])

def triangle_number(n):
    return sum(range(1, n+1))

def product(ls):
    return reduce(lambda l, acc: l * acc, ls, 1)
    
i = 7
value = triangle_number(i)
num_divisors = number_of_divisors(value)

limit = 500
# limit = 5
while num_divisors < limit:
    i += 1
    value = triangle_number(i)
    num_divisors = number_of_divisors(value)

print(value)
print(value == 76576500)
